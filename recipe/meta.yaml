{% set sdata = load_setup_py_data() %}
{% set name = "prefect" %}
{% set version = "0.13.10" %}




# Maps dependency names in pip to their conda alternative
{%
  set name_mapping =
  {
    "msgpack": "msgpack-python",
    "docker": "docker-py",
    "dask": "dask-core",
  }
%}

{% macro map_dep_name(dep) -%}
  {# Updates dependency names to conda names using `name_mapping` #}

  {# Ensure the white space is trimmed then parse the name #}
  {% set dep = dep | trim %}
  {% set dep_name = dep.split(" ")[0] %}

  {# Update the name if it's in the mapping, otherwise leave it as is #}
  {% if dep_name in name_mapping %}
    {{ dep | replace(dep_name, name_mapping[dep_name]) }}
  {% else %}
    {{ dep }}
  {% endif %}

{%- endmacro %}

{% macro fix_dep_version(dep) -%}
  {# Ensure that versions are specified as {NAME} {SPEC}{NUMBER} e.g. python >=3.8 #}
  {# Expects that {NAME} and {SPEC} are already separated by a space #}
  {# Better handling could be implemented here with regex_replace but it is not available #}

  {# Parse the dependency into name and version spec #}
  {% set dep = dep | trim %}
  {% set dep_parts = dep.split(" ") %}
  {% set dep_name = dep_parts[0] %}

  {# If there is a version spec, ensure it has no spaces in it #}
  {% if dep_parts | length > 1 -%}
    {% set dep_spec = dep_parts[1:] | join("") %}
    {{ "{} {}".format(dep_name, dep_spec) }}

  {# Otherwise just return it as a name #}
  {% else -%}
    {{ dep_name }}
  {% endif %}
{%- endmacro %}

{% macro list_requirements(dep_lst) -%}
  {# Convert a list of requirements to a formatted string. #}
  {# Recommend use of ` | indent(#)` to match indent level where used #}
  {% for dep in dep_lst -%}
- {{ map_dep_name(fix_dep_version(dep)) | trim }}
  {% endfor %}
{%- endmacro %}

package:
  name: {{ name|lower }}
  version: {{ version }}

source:
  url: https://pypi.io/packages/source/{{ name[0] }}/{{ name }}/{{ name }}-{{ version }}.tar.gz
  sha256: 063566bd3b1043236d43cdc1a91935acaec3b46e4f1a46937f61d3d33613525a

build:
  noarch: python
  number: 0
  script: {{ PYTHON }} -m pip install --no-deps -vv .
  entry_points:
    - prefect = prefect.cli:cli

requirements:
  host:
    - python {{ sdata['python_requires'] }}
    - pip
  run:
    - python {{ sdata['python_requires'] }}
    {{ list_requirements(sdata['install_requires']) | indent(2) }}

test:
  imports:
    - prefect
    - prefect.triggers
    - prefect.schedules
    - prefect.tasks.shell
    - prefect.tasks.control_flow
    - prefect.tasks.github
  requirements:
    run:
      {{ list_requirements(sdata['extras_require']['test']) | indent(4) }}

output:
  # The main build
  - name: prefect
  # Cloud specific builds
  - name: prefect-aws
    requirements:
      run:
        - prefect =={{ version }}
        {{ list_requirements(sdata['extras_require']['aws']) }}
  - name: prefect-azure
    requirements:
      run:
        - prefect =={{ version }}
        {{ list_requirements(sdata['extras_require']['azure']) | indent(6) }}
  - name: prefect-gcp
    requirements:
      run:
        - prefect =={{ version }}
        {{ list_requirements(sdata['extras_require']['gcp']) | indent(6) }}
  - name: prefect-kubernetes
    requirements:
      run:
        - prefect =={{ version }}
        {{ list_requirements(sdata['extras_require']['kubernetes']) | indent(6) }}


about:
  home: https://github.com/PrefectHQ/prefect
  license: Apache-2.0
  license_family: Apache
  license_file: LICENSE
  summary: 'The Prefect Core automation engine '
  description: |
    Prefect is a new workflow management system, designed for modern
    infrastructure and powered by the open-source Prefect Core workflow engine.
    Users organize `Tasks` into `Flows`, and Prefect takes care of the rest.
  doc_url: https://docs.prefect.io/

extra:
  recipe-maintainers:
    - cicdw
    - jcrist
    - joshmeek
    - dhirschfeld
    - rzillman
